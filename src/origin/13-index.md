#### 例题

```js

console.log( [] == ![] ) ?

```

在浏览器控制台打印下竟然是true，对于从事js开发两到三年的人来说，不一定深究过为什么是这样的结果，当场惊掉小巴。

#### 下面我们分析下为什么是这样的结果。

由于！运算符的优先级别高于 ==  所以 先把 空数组转为布尔类型true，取反后为false。此时为

[] == false ，空数组和布尔值比较相等。这种情况下两个类型不同。js隐式转换规则会把布尔值转为数字再比较，

[] == 0 此时，一个引用类型的值与数字作比较，引用类型需要转换为原始类型去做比较。

引用类型转换原始类型的规则是什么呢？

如果该引用类型存在 Symbol.toPrimitive 这个方法的话，会优先使用此方法。

例如

```js

var obj = {
  value: 0,
  valueOf() {
    return 1;
  },
  toString() {
    return '2'
  },
  [Symbol.toPrimitive]() {
    return 3
  }
}
console.log( obj + 1 ); // 输出4

```

不存在此方法的话。如果该对象是Date类型的话，优先调用toString( )方法，如果返回了原始值，则结束。否则调用valueOf( )方法，如果返回原始值则结束，否则报错。

如果该对象不是Date类型，优先调用valueOf( )方法，如果返回了原始值则结束。否则调用toString( )方法，如果返回原始值则结束，否则报错。

继续上面例题的分析。空数组会优先调用valueOf，发现返回的依然是对象，则调用toString返回了空字符串。所以转换为

''  ==  0 作比较，根据隐式转换规则会把字符串转为数字比较也就是 0 == 0 ，结果显而易见就是true。

#### 下面我们介绍下js的隐式转换规则。

当两个类型相同的值作比较的话。直接比较即可。注意 NaN  == NaN 返回 false 

1、字符串与数字比较 会把字符串转为数字再做比较 

2、布尔值与数字比较 会把布尔值转为数字再做比较

3、布尔值与字符串比较 会把布尔值转为数字 ，字符串也转为数字再做比较

4、引用类型的值与字符串或数字比较的话，先把引用类型的值转为原始类型然后再作比较

#### 还有一道题很有意思

```js
 
new Date() + new Date()

new Date() - new Date() 
 
```

打印一下看看